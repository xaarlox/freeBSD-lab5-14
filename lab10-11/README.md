# freeBSD_lab10-11
## Завдання з DumbShell
Програма реалізовує примітивну командну оболонку (shell), яка працює в нескінченному циклі. Вона зчитує введену користувачем команду, видаляє символ нового рядка та перевіряє, чи введено "exit" – у такому разі завершує роботу. Для виконання команди створюється новий дочірній процес за допомогою `fork()`. У дочірньому процесі виконується команда через `execlp`, а якщо виконання не вдається – виводиться повідомлення про помилку. Батьківський процес очікує завершення дочірнього, перш ніж продовжити роботу.
### Компіляція та виконання завдання
![Знімок екрана 2025-06-03 160700](https://github.com/user-attachments/assets/225b8525-94ad-4df9-8349-5f3cacdc5c64)

## Завдання з API wait
У лекції був наведений додатковий фрагмент, який потрібно було інтегрувати в попередній код, щоб мати змогу переглядати та аналізувати результат виконання дочірнього процесу:
```
#include <sys/wait.h>

int status;
pid_t pid = wait(&status);

if (WIFEXITED(status)) {
    printf("Exited with code %d\n", WEXITSTATUS(status));
}
```
Різниця з попереднім кодом полягає в тому, що тут додано обробку статусу завершення дочірнього процесу за допомогою `wait(&status)` та макросів `WIFEXITED`, `WEXITSTATUS`, `WIFSIGNALED`, `WTERMSIG`. Це дозволяє більш детально повідомити користувача про те, як саме завершилась команда (нормально чи внаслідок сигналу). Попередній варіант просто чекав завершення без виведення такої інформації.
### Компіляція та виконання завдання
![Знімок екрана 2025-06-03 161904](https://github.com/user-attachments/assets/5d0d818b-326b-4e29-9306-8180cbf81261)

## Fork Bomb
`:(){ :|:& };:` – це спеціально написаний shell-скрипт, що швидко генерує величезну кількість процесів, поки система не виснажить усі доступні ресурси, як-от процесорний час, пам'ять чи дескриптори процесів, і не зависне або перезавантажиться.

Скрипт визначає функцію з іменем `:`, яке є допустимим у bash. Усередині функції вона викликає сама себе двічі через конвеєр, створюючи нові процеси. Завдяки символу `&` виконання відбувається у фоновому режимі, тому функція не чекає завершення дочірніх процесів. Після першого виклику процеси починають розмножуватися експоненційно, оскільки кожен із них породжує ще два нових. Така безконтрольна рекурсія призводить до стрімкого вичерпання системних ресурсів, що робить систему непридатною для роботи.

Зазвичай цей код використовують, щоб продемонструвати необхідність обмеження кількості процесів, які може створити користувач, через параметр `ulimit -u` у Linux.

## Приклад створення кількох дітей
Цей приклад реалізовує просту оболонку, яка зчитує команди від користувача та виконує їх у дочірньому процесі. Перед виконанням команди, програма створює три додаткові дочірні процеси, які одразу завершуються (виводячи Child 0, Child 1, Child 2), і батьківський процес чекає завершення всіх трьох. Лише після цього виконується основна команда, введена користувачем.

Використовується `execlp`, щоб запустити команду в новому дочірньому процесі. Батьківський процес чекає завершення цієї команди та повідомляє, чи завершилась вона успішно (`Exited with code`) чи була перервана сигналом (`Terminated by signal`). Таким чином, дана версія демонструє як створювати кілька процесів вручну та як послідовно чекати їх завершення перед виконанням основної задачі.
### Компіляція та виконання завдання
![Знімок екрана 2025-06-03 162507](https://github.com/user-attachments/assets/8c346f07-9215-42f5-bde1-9f67da6a31c9)

## Завдання №20
Створіть дерево процесів, у якому кожен нащадок створює ще одного. Переконайтесь, що всі процеси завершуються правильно, навіть якщо батьківський процес завершується раніше.
### Реалізація завдання
Було написано програму, яка рекурсивно створює дерево процесів до певної глибини, де кожен процес породжує рівно одного нащадка. Таким чином формується структура, схожа на вертикальний ланцюг, де кожен процес – батько наступного.
+ **Рекурсивне створення процесів**. Функція `create_process_tree(int level)` запускає процеси до досягнення максимального рівня `MAX_DEPTH`. Якщо поточний рівень досягає `MAX_DEPTH`, створення завершується, і виводиться повідомлення про "листовий" процес.
+ **Використання fork()**. Кожен процес виконує `fork()`, щоб створити дочірній. У дочірньому процесі виконується рекурсивний виклик `create_process_tree(level + 1)`. У батьківському – лише фіксується створення, затримка `sleep(1)` і завершення.
+ **Вивід інформації**. Кожен процес виводить на екран свій рівень, PID, PPID та статус (дитина/батько), що дозволяє наочно простежити структуру дерева процесів.
+ **Без wait()**. Батьківський процес не чекає завершення нащадків, а лише робить `sleep(1)` і виходить. Це імітує, що кожен процес "відпускає" свою дитину далі по дереву і сам завершується.

Результат виконання – ланцюжок з п’яти процесів, кожен з яких породжує наступний і сам припиняється, залишаючи нащадка працювати далі.
### Компіляція та виконання завдання
![Знімок екрана 2025-06-03 162952](https://github.com/user-attachments/assets/7b4cf406-f132-4f5d-8a41-81682c866258)
