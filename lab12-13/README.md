# freeBSD_lab12-13
## Завдання №20
Напишіть програму, що у випадку SIGSEGV намагається проаналізувати стек і визначити, чи можливо «відкотитися» на безпечну точку виконання.
### Реалізація завдання
Було написано програму, яка демонструє обробку помилки сегментації (SIGSEGV) з подальшим відновленням виконання програми за допомогою механізму `setjmp`/`longjmp`. Програма також показує, як отримати стек викликів на момент помилки.

**Примітка:** цей підхід не є безпечним для використання у production-коді, однак корисний для налагодження або демонстрації.

+ **Ініціалізація точки безпечного повернення**. Використовується `sigsetjmp()` для збереження поточного стану виконання у глобальну змінну `safe_point`, щоб мати змогу повернутись до цього місця після обробки помилки.
+ **Встановлення обробника сигналу**. Через `sigaction()` задається власна функція-обробник `segv_handler`, яка буде викликана при виникненні сигналу `SIGSEGV`. Встановлюється прапор `SA_SIGINFO` для отримання додаткової інформації про сигнал.
+ **Обробка помилки сегментації**. У функції `segv_handler()` відбувається:
  - ігнорування непотрібних аргументів;
  - зняття стеку викликів функцією `backtrace()` і вивід його на stderr через `backtrace_symbols_fd()`;
  - повідомлення про спробу відновлення;
  - повернення до точки, заданої `sigsetjmp()`, за допомогою `siglongjmp()`.

+ **Імітація помилки сегментації**. У функції `cause_segfault()` спеціально здійснюється запис у нульовий покажчик (`*ptr = 42;`), що викликає `SIGSEGV`.
+ **Відновлення виконання після помилки**. Після повернення з `siglongjmp()`, програма продовжує виконання у гілці `else` і повідомляє про успішне відновлення, завершуючись нормальним чином.

### Компіляція та виконання завдання
![Знімок екрана 2025-06-03 164845](https://github.com/user-attachments/assets/bcec2f36-ab45-401c-ae5d-7ba00db73eed)
