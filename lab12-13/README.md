# freeBSD_lab12-13
## Handling Signals
Програма встановлює обробник сигналу `SIGINT`, який викликається при натисканні `Ctrl+C` у терміналі. Замість завершення виконання, вона виводить повідомлення з номером сигналу та продовжує працювати в нескінченному циклі.
### Компіляція та виконання завдання
![image](https://github.com/user-attachments/assets/12898863-bbab-4c34-baf1-f2684bb16a78)

## A Simple C Program that Handles a Couple of Signals
Програма встановлює обробники для сигналів `SIGINT` (Ctrl+C) та `SIGTERM`. При натисканні Ctrl+C вона лише виводить повідомлення, не завершуючи виконання. При отриманні сигналу `SIGTERM` програма виводить повідомлення та завершується за допомогою `_exit(0)`. У головній функції програма друкує свій PID і переходить у нескінченний цикл зі сном. Завершити її можна, надіславши `SIGTERM` за допомогою команди `kill`.
### Компіляція та виконання завдання
![image](https://github.com/user-attachments/assets/a849e93c-fc02-437e-9894-958d65975814)

## Sigaction Flags
Програма встановлює розширений обробник сигналу `SIGINT` (Ctrl+C) за допомогою `sigaction()` з прапорами `SA_SIGINFO` і `SA_RESTART`. При натисканні Ctrl+C вона виводить повідомлення та PID процесу, що надіслав сигнал, але не перериває системний виклик `read()`. Після введення тексту і натискання Enter програма виводить введений рядок і завершується.
### Компіляція та виконання завдання
![image](https://github.com/user-attachments/assets/b7e08688-2df9-4fd9-a3cf-a505a571245a)

## No Zombies
Програма створює дочірній процес за допомогою `fork()` і не викликає `wait()` у батьківському процесі. Щоб уникнути появи зомбі, встановлюється обробка сигналу `SIGCHLD` з прапором `SA_NOCLDWAIT` і обробником `SIG_IGN`. Дочірній процес завершується самостійно після затримки, а батьківський продовжує виконання без необхідності явно очікувати на завершення дитини.
### Компіляція та виконання завдання
![image](https://github.com/user-attachments/assets/f5e98414-24b4-48ac-840b-8af99f349deb)

## Trapping and Extracting Information from a Crash
Програма встановлює розширений обробник для сигналу `SIGSEGV` за допомогою `sigaction()` з прапором `SA_SIGINFO`. При спробі запису в нульовий вказівник виникає помилка сегментації, після чого обробник виводить номер сигналу і адресу, що спричинила збій, а потім завершує програму.
### Компіляція та виконання завдання
![image](https://github.com/user-attachments/assets/0ced4e6b-5d05-4d8a-a8e6-1650a3dc22d6)

## A Small Publisher-Subscriber Type of Application
Ця пара програм демонструє передачу даних між процесами за допомогою сигналу `SIGRTMIN`. subscriber встановлює розширений обробник сигналу, який виводить PID відправника і значення, передане через `sigqueue`. publisher надсилає сигнал `SIGRTMIN` конкретному процесу разом із цілим значенням 99.
### Компіляція та виконання завдання
![image](https://github.com/user-attachments/assets/10657eeb-97fa-49f2-8c23-3b486dd45bcd)

## Завдання №20
Напишіть програму, що у випадку SIGSEGV намагається проаналізувати стек і визначити, чи можливо «відкотитися» на безпечну точку виконання.
### Реалізація завдання
Було написано програму, яка демонструє обробку помилки сегментації (SIGSEGV) з подальшим відновленням виконання програми за допомогою механізму `setjmp`/`longjmp`. Програма також показує, як отримати стек викликів на момент помилки.

**Примітка:** цей підхід не є безпечним для використання у production-коді, однак корисний для налагодження або демонстрації.

+ **Ініціалізація точки безпечного повернення**. Використовується `sigsetjmp()` для збереження поточного стану виконання у глобальну змінну `safe_point`, щоб мати змогу повернутись до цього місця після обробки помилки.
+ **Встановлення обробника сигналу**. Через `sigaction()` задається власна функція-обробник `segv_handler`, яка буде викликана при виникненні сигналу `SIGSEGV`. Встановлюється прапор `SA_SIGINFO` для отримання додаткової інформації про сигнал.
+ **Обробка помилки сегментації**. У функції `segv_handler()` відбувається:
  - ігнорування непотрібних аргументів;
  - зняття стеку викликів функцією `backtrace()` і вивід його на stderr через `backtrace_symbols_fd()`;
  - повідомлення про спробу відновлення;
  - повернення до точки, заданої `sigsetjmp()`, за допомогою `siglongjmp()`.

+ **Імітація помилки сегментації**. У функції `cause_segfault()` спеціально здійснюється запис у нульовий покажчик (`*ptr = 42;`), що викликає `SIGSEGV`.
+ **Відновлення виконання після помилки**. Після повернення з `siglongjmp()`, програма продовжує виконання у гілці `else` і повідомляє про успішне відновлення, завершуючись нормальним чином.

### Компіляція та виконання завдання
![Знімок екрана 2025-06-03 164845](https://github.com/user-attachments/assets/bcec2f36-ab45-401c-ae5d-7ba00db73eed)
